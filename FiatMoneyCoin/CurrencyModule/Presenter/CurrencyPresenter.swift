//
//  CurrencyPresenter.swift
//  FiatMoneyCoin
//
//  Created tambanco ðŸ¥³ on 05.07.2022.
//
//  Template generated by Tambanco
//

import Foundation
import UIKit
import CoreData

// MARK: Output protocol
protocol CurrencyViewProtocol: AnyObject {
    func success()
    func failure(error: Error)
    func updatePickerView(filteredData: [String])
    func dismissView()
}

// MARK: Input protocol
protocol CurrencyPresenterProtocol: AnyObject {
    var newValueToSave: String? { get set }
    var newSymbolToSave: String? { get set }
    var symbols: [String]? { get set }
    var baseCurrency: String { get }
    var convertedCurrency: String? { get set }
    var storageService: StorageService? { get set }
    var filteredData: [String] { get set }
    
    func fetchSearchText(searchText: String)
    func saveToCoreData()
    func cancelAdding()
    init(router: RouterProtocol, view: CurrencyViewProtocol, networkService: NetworkServiceProtocol)
}

class CurrencyPresenter: CurrencyPresenterProtocol {
    var filteredData: [String] = []
    var convertedCurrency: String?
    var baseCurrency: String = "RUB"
    var newValueToSave: String?
    var newSymbolToSave: String?
    var storageService: StorageService? = StorageService()
    var symbols: [String]? = []
    
    weak var view: CurrencyViewProtocol?
    var router: RouterProtocol?
    var networkService: NetworkServiceProtocol?
    
    
    func fetchSearchText(searchText: String) {
        guard let symbols = symbols else { return }
        if !symbols.isEmpty {
            filteredData = symbols.filter { $0.contains(searchText)}
            print(filteredData)
        } else {
            filteredData = symbols
        }
        self.view?.updatePickerView(filteredData: filteredData)
    }
    
    func saveToCoreData() {
        currencyConverter(amount: newValueToSave, symbol: newSymbolToSave)
        storageService?.saveNewValue(newValue: newValueToSave, newSymbol: newSymbolToSave)
        router?.popToRoot()
        self.view?.dismissView()
    }
    
    func currencyConverter(amount: String?, symbol: String?) {
        guard symbol != nil else { return }
        let symbolToConvert = symbol!
        let currencyCode = String(symbolToConvert.prefix(3))
        networkService?.convertTwoCurrensies(from: currencyCode, to: baseCurrency, amount: amount ?? "", completion: { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(let convertedValue):
                guard let convertedValue = convertedValue else { return }
                let doubleConvertedValue = Double(convertedValue)
                
                guard let doubleConvertedValue = doubleConvertedValue else { return }
                
                let formatter = NumberFormatter()
                formatter.numberStyle = .currency
                if formatter.string(from: doubleConvertedValue as NSNumber) != nil {
                    DispatchQueue.main.async {
                        self.convertedCurrency = convertedValue
                        self.storageService?.saveCurrency(totalValue: self.newValueToSave,
                                                          convertedValue: self.convertedCurrency,
                                                          currencySymbol: self.newSymbolToSave)
                    }
                    
                }
            case .failure(let error):
                print(error.localizedDescription)
            }
        })
    }
    
    func cancelAdding() {
        router?.popToRoot()
        self.view?.dismissView()
    }
    
    required init(router: RouterProtocol, view: CurrencyViewProtocol, networkService: NetworkServiceProtocol) {
        self.router = router
        self.view = view
        self.networkService = networkService
        
        getSymbols()
    }
    
    func getSymbols() {
        networkService?.getCurrencyList(completion: { [weak self] result in
            guard let self = self else { return }
            switch result {
            case .success(let symbols):
                self.symbols = symbols
                DispatchQueue.main.async {
                    guard let symbols = symbols else { return }
                    self.filteredData = symbols
                    self.view?.success()
                }
            case .failure(let error):
                self.view?.failure(error: error)
            }
        })
    }
}
